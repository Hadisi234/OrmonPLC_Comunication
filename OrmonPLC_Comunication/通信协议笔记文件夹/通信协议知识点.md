# 视频知识

[视频链接](https://www.bilibili.com/video/BV1oe4y1m72C/?p=68&share_source=copy_web&vd_source=b83eef0c8a1f48fdadaa97e04126b0b9)

这个视频主要是讲PLC的有些地方上位机用不上（1.1到1.5，后面是我从网上找到的知识），或者有些冲突。主要以理解网络概念为主。

## **1.1 EtherCAT概述**

EtherCAT简介（EtherNet Control Automation Technology），2003年由倍福发明，2014年成为我国的国标。

- EtherCAT（以太网控制自动化技术）是以以太网为基础的开放架构的现场总线系统。总线就是用来通信的
- EtherCAT是基于以太网但比以太网更高速和高效的一种高性能工业网络系统。（现由ETG掌握及推广）

EtherCAT网络的特点

- 开放、通用
- 高速、稳定
- 拓扑灵活
- 通信数据输入/输出各5736个字节
- 最多192个从站（NJ系列的欧姆龙PLC可以带192个）
- 两个设备之间距离最长100米

与其它厂商EtherCAT从站设备通信

- ESI文件包含EtherCAT从站的特征信息（.Xml文件格式），主要提供设备信息



**为什么EtherCat不需要去计算Mac地址？**
EtherCAT 是一种实时以太网技术，它通常不需要计算 MAC 地址，主要有以下几个原因：

1. EtherCAT 基于以太网技术，但它具有自己独特的通信机制和帧结构。在 EtherCAT 网络中，从站设备通常不是通过传统的以太网 MAC 地址来进行识别和通信的。
2. EtherCAT 采用了主从式的通信架构，**主站负责控制整个网络的通信和数据传输，从站设备按照主站发送的帧中的特定位置和指令进行响应**。
3. EtherCAT 的通信帧在经过每个从站时，从站会根据帧中的特定信息进行处理和数据交换，而不是依赖 MAC 地址来确定通信的目标。
4. 这种特殊的通信方式和帧结构设计使得 EtherCAT 能够实现高效的实时通信，减少了传统以太网中基于 MAC 地址的寻址和路由带来的延迟和复杂性。



**OSI 模型分为七层**：

1. 物理层：负责在物理介质上传输比特流。
2. 数据链路层：将比特组合成帧，并进行错误检测和纠正。
3. 网络层：负责数据包的路由和转发。
4. 传输层：提供端到端的可靠或不可靠的数据传输服务。
5. 会话层：建立、管理和终止会话。
6. 表示层：处理数据的表示方式，如加密、压缩等。
7. 应用层：为应用程序提供网络服务。

**TCP/IP 模型通常分为四层**：

1. 网络接口层：对应 OSI 模型的物理层和数据链路层。
2. 网络层：对应 OSI 模型的网络层，主要协议是 IP。
3. 传输层：对应 OSI 模型的传输层，主要协议是 TCP 和 UDP。
4. 应用层：对应 OSI 模型的会话层、表示层和应用层。

**EtherCat需要IP吗**？

EtherCAT 本身不需要 IP 地址来进行通信。EtherCAT 是一种基于以太网的工业以太网技术，它使用以太网帧进行数据传输，但不像传统的以太网通信那样依赖于 IP 地址进行网络寻址和路由。
然而，在一些更复杂的网络架构中，可能会将 EtherCAT 网络与基于 IP 的网络集成，此时可能会为 EtherCAT 设备分配 IP 地址，但这并非 EtherCAT 通信的必需条件。

在 EtherCAT 与 IP 集成的情况下，虽然数据是封装在 IP 数据包中进行传输，但 EtherCAT 本身的通信机制通常并不依赖于传统以太网中的 MAC 地址来进行设备识别和数据交换。
然而，**从整个网络通信的角度来看，当在以太网环境中传输 IP 数据包时，底层的以太网通信确实需要 MAC 地址来确定数据帧的目标。**
但这主要是由以太网的物理层和数据链路层处理，对于 EtherCAT 的应用层通信逻辑来说，其重点仍然是 EtherCAT 特定的帧结构和控制机制。
所以，从严格意义上讲，这种集成情况下，在以太网传输层面是需要 MAC 地址的，但对于 EtherCAT 的核心通信机制，MAC 地址并非其关键的识别和控制要素。



## 1.2 EtherNet/IP概述

### 1.2.1 EtherNet/IP概述

1. EtherNet/IP是控制器与控制器之间的网络，同样可以作为一种控制现场的网络来使用。另外由于使用开发的以太网技术，可以实现多厂商联合的工业网络。（现由ODVA掌握及推广，也是基于以太网的改进）

2. EtherNet/IP是使用了以太网的标准协议TCP/IP的符合世界规格工业用以太网。**应用层封装了CIP（通用工业协议），具有与ODVA的CIP网络间无缝通信的特长。简称EIP。**在PLC与上位机通信、组态时和PLC间数据共享时可以使用。

   - 注：1、CIP是通用工业协议，DeviceNet、ControlNet、CompoNet网络也都支持CIP

     ​	2、ODVA是由全世界自动化领导企业组成的一个国际性组织。

![image-20240919113605014](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240919113605014.png)

### 1.2.2 EIP网络的作用

- 控制器间互相通信
- 通过标签数据链接（Tag data link）实现灵活的通信
- 与触摸屏或上位机组态软件通信
- 与Sysmac Studio 通信
- 与第三方设备通信

## 1.3 标签数据链接（Tag Data Link）概述

### 1.3.1 CIP通信的分类

1. 标签数据链接（每一个数据周期都会进行输入输出，进行数据更新。自动）
   - 周期通信
   - UDP协议（端口2222）
   - 32个链接（NJ欧姆龙PLC支持）
   - 常时自动更新
2. 报文通信（报文触发，需要的时候进行读取）
   - Class3或UCMM通信
   - TCP协议（端口44818）
   - 32个通信（NJ欧姆龙PLC支持）
   - CIP专用指令

### 1.3.2 标签数据链接概念

​	标签数据链接是指通过EIP在设备之间进行周期性的数据交换的一种功能；标签数据链接的设定是通过Network Configurator for EtherNet/IP这个软件来实现的。通信是以标签为基础的，一个标签组最多8个标签，一个链接就是一个标签组，一个链接最多600个字节，链接数据最多9600个字。不够可以增加EIP模块。

#### 1.3.2.1 连接方式

1. 组播方式（Multi-cast connection）：多点传送
   - 输出类标签组面向整个网络广播
   - 输出类标签组传送给多个节点时，用这种方式只需一次打包发送数据；
   - 如有的节点不需要接受数据包，可使用带组播过滤功能的以太网交换机
2. 点对点方式（Unicast connection）：单点传送
   - 输出类标签组独立地发给各个节点；
   - 一个输出类标签组传递给多个节点时，用这种方式需多次打包发送数据

## 1.4 CIP报文通信

### 1.4.1 报文通信概念

- 通过CIP命令完成EtherNet/IP网络设备间变量数据读写
- CIP命令能在EIP网络运行过程中的任何时刻被请求发送到其他设备

![image-20240919132533945](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240919132533945.png)

#### 1.4.1.1 报文通信的变量

- 设置**网络公开**属性的**全局变量**
- 具有**网络公开**属性的**系统变量**

#### 1.4.1.2 报文通信的方式

1. UCMM方式（UnConnected Message Manager）
   - UCMM为非连接报文管理器
   - 使用UCMM方式时请求设备和应答设备之间是不组成连接
   - 效率高，但可靠性不高
2. Class3方式
   - Class3为连接报文通信；
   - Class3方式下请求数据，需先使用CIPOpen指令来建立请求设备和应答设备之间的连接，直到使用CIPClose指令前，连接会一直保持下去。
   
   ![image-20240919135429952](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240919135429952.png)

## 1.5 FINS

Fins指令需使用具有"AT指定"属性的变量

![image-20240919154329416](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240919154329416.png)



# 博客（网上找的）

## CIP协议

CIP通信是Common Industrial Protocl(CIP)的简称，它是一个点到点的面向对象协议，能够实现工业器件（传感器，执行器）之间的连接，和高等级的控制器之间的连接。目前，**有3种网络DeviceNet，ControlNet，EtherNet/IP使用CIP通信协议作为其上层网络协议**，由ODVA组织统一管理，以确保其一致性和精确性。

### 1.1 EtherNet/IP

　EtherNet/IP(Ethernet/Industrial Protocol)，是一个工业级的通信网络，用于工业器件	间高速的信息交换，这些器件包括简单的IO器件（传感器），还有复杂的控制器（机器人，PLC，焊机，过程控制器）。EtherNet/IP使用CIP(Common Industrial Protocl),其使用EtherNet和TCP/IP技术传送CIP通信包，CIP作为开放的应用层，位于EtherNet和TCP/IP协议之上。

### 1.2 CIP通信报文

注册会话ID

```c#
private byte[] Registercmd = new byte[28]
{

　　//--------------------------------------------------------Header 24byte-------------------------------------
　　0x6F,0x00,//命令 2byte
　　0x04,0x00,//Header后面数据的长度 2byte
　　0x00,0x00,0x00,0x00,//会话句柄 4byte
　　0x00,0x00,0x00,0x00,//状态默认0 4byte
　　0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//发送方描述默认0 8byte
　　0x00,0x00,0x00,0x00,//选项默认0 4byte

       //-------------------------------------------------------CommandSpecificData 指令指定数据 4byte

　　0x01,0x00,//协议版本 2byte

　　0x00,0x00,//选项标记 2byte
};
```

提交会话ID-注册请求的应答报文

```c#
private byte[] RefRegistercmd = new byte[28] 
{

　　//--------------------------------------------------------Header 24byte-------------------------------------
　　0x6F,0x00,//命令 2byte
　　0x04,0x00,//CommandSpecificData的长度 2byte
　　0x6B,0x01,0x01,0x00,//会话句柄 4byte 由PLC生成
　　0x00,0x00,0x00,0x00,//状态默认0 4byte
　　0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//发送方描述默认0 8byte
　　0x00,0x00,0x00,0x00,//选项默认0 4byte

   //-------------------------------------------------------CommandSpecificData 指令指定数据 4byte

　　0x01,0x00,//协议版本 2byte

　　0x00,0x00,//选项标记 2byte
};
public byte[] SessionHandle=new byte[4]{0x6B,0x01,0x01,0x00};//从应答报文提取的会话ID
```

读取数据服务的请求报文

报文由三部分组成Header24个字节、CommandSpecificData16个字节、以及CIP消息（由读取的标签生成）实例，读取单个标签名为TAG1的报文总长度为64个字节

```c#
private byte[] Header = new byte[24]
{
　　0x6F,0x00,//命令 2byte
　　0x28,0x00,//长度 2byte（总长度-Header的长度）=40 
　　0x6B,0x01,0x01,0x00,//会话句柄 4byte
　　0x00,0x00,0x00,0x00,//状态默认0 4byte
　　0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//发送方描述默认0 8byte
　　0x00,0x00,0x00,0x00,//选项默认0 4byte
};

private byte[] CommandSpecificData = new byte[16]
{
　　0x00,0x00,0x00,0x00,//接口句柄 CIP默认为0x00000000 4byte
　　0x01,0x00,//超时默认0x0001 4byte
　　0x02,0x00,//项数默认0x0002 4byte
　　0x00,0x00,//空地址项默认0x0000 2byte
　　0x00,0x00,//长度默认0x0000 2byte
　　0xb2,0x00,//未连接数据项默认为 0x00b2
　　0x18,0x00,//后面数据包的长度 24个字节(总长度-Header的长度-CommandSpecificData的长度)
};

private byte[] CipMessage = new byte[24]
{

 　 0x52,0x02　　   //服务默认0x52  请求路径大小 默认2
　　0x22,06,0x24,0x01,//请求路径 默认0x01240622 4byte
　　0x0A,0xF0,//超时默认0xF00A 4byte
　　0x0A,0x00,//Cip指令长度  服务标识到服务命令指定数据的长度 
　　0x4C,//服务标识固定为0x4C 1byte  
　　0x03,// 节点长度 2byte  规律为 (标签名的长度+1/2)+1
　　0x91,//扩展符号 默认为 0x91
　　0x04,//标签名的长度

　　0x54,0x41,0x47,0x31,//标签名 ：TAG1转换成ASCII字节 当标签名的长度为奇数时，需要在末尾补0  比如TAG转换成ASCII为0x54,0x41,0x47，

     需要在末尾补0 变成 0x54,0x41,0x47，0

　　0x01,0x00,//服务命令指定数据　默认为0x0001　

　  0x01,0x00,0x01,0x00//最后一位是PLC的槽号

};
```

PLC回复报文：

6F0018006B01010000000000000000000000000000000000000000000100020000000000B200 08 00 CC 00 0000 C100 0000　

CC-服务标识 00-填充字节 0000-状态 0为正常 0800:CC-0000的长度 C100-数据类型：Bool  0000为数据false



------

 

 实例，读取多个标签名为 TAG、TAG1的报文总长度为86个字节

6F003E006B01010000000000000000000000000000000000000000000100020000000000B2002E005202200624010AF020000A02200224010200060010004C0391035441470001004C03910454414731010001000100

Header：6F003E006B01010000000000000000000000000000000000   24byte   

CommandSpecificData: 00 00 00 00 0100020000000000B2002E00   16byte  

CipMessage:52 02 20062401 0AF0 2000 0A 02 20022401 0200 0600 1000 4C0391 03 54414700 0100 4C039104544147310100 01000100

52-服务代码 02 -请求路径大小 20062401-请求路径 0AF0超时  20 00 CIP指令长度 （0A-00之间的长度为32个字节）

0A-服务代码（多个标签） 02-请求路径大小 20022401请求路径 0200 标签的数量 0600 偏移量（初始值为：2+标签数量*2）

1000 偏移量 =标签服务长度+初始偏移量（有几个标签就有几个偏移量）

4C 03 91 03 54414700 0100 标签TAG 4C039104544147310100 标签TAG1

PLC回复报文：

6F0034006B01010000000000000000000000000000000000000000000100020000000000B20024008A000000020006001300CC000000D00005003232323232CC000000D00005003232323232  76byte

Header:6F0034006B01010000000000000000000000000000000000 24byte

CommandSpecificData:000000000100020000000000B2002400 16byte

CipMessage:8A00 0000 0200 0600 1300 CC 00 0000 D000 0500 3232323232 CC000000D00005003232323232

8A-多个标签  0000 -状态 0200-项数 0600-标签TAG偏移量 1300-标签TAG1偏移量 0000-状态0正常 D000-数据类型：string 

0500:字符串长度（字符串类型特有的）

3232323232-数据 "22222"：

目前常用的数据类型: C1-BOOL C2-SINT C3-Short C4-Int C7-UShort C8-UInt CA-Float CB -Double D0-String

**4.写入数据服务报文**

实例，往标签名为：TAG1 写入true 数据类型为 bool

写入报文：68byte

6F002C006B01010000000000000000000000000000000000 000000000100020000000000B2001C00 5202200624010AF00E004D03910454414731C1000100010001000100   

header：6F002C006B01010000000000000000000000000000000000  24byte

CommandSpecificData:000000000100020000000000B2001C00   16byte

CIPmessage：52 02 20062401 0AF0 0E00 4D 03 91 04 54414731 C100 0100 0100 01000100  28byte

52-服务标识   02-请求路径大小 20062401-请求路径，默认  0AF0-超时      0E00-CIP指令长度（绿色部分的长度）

4D-写入标识   03-（标签名的长度+1）/2+1  91-扩展符号  04-标签TAG1的长度  54414731 -标签名的ASCII表示

C100-数据类型  0100-默认项  0100-数据 TRUE（2byte）     01000100 - 默认最后一位为PLC槽号

PLC回复报文：

6F0014006B0101 00000 00000000000000000000000000000 000000000100020000000000B2000400CD000000  44byte

header:6F0014006B01010000000000000000000000000000000000 24byte

 CommandSpecificData:000000000100020000000000B2000400 16byte

CIPMessage:CD 00 0000   CD-服务标识 00-填充字节 0000-状态好

注意:当写入字符串类型时，写入的数据长度为奇数时，需要在数据后填充一个字节0

------

 

5.扩展知识

 首先建立起TCP连接，CIP通信端口默认为44818。TCP连接成功后，发送会话消息，获取四个字节的会话ID，就可以正常读写了。

header:6F0014006B0101 0000 000000000000000000000000000000 24byte

　 0x0000：状态正常(在报文里低位在前高位在后)

　 0x0001:发出了无效或不受支持的封装命令;

　 0x0002:接收器中的内存资源不足，无法处理命令;

　 0x0003:封装消息的数据部分中的数据形成不良或不正确;

　 0x0004:Reserved for legacy(RA);

　 0x0064:向目标发送封装消息时，始发者使用了无效的会话句柄;

​    0x0065:目标收到一个无效长度的信息

​    0x0069:不支持的封装协议修订

CIPMessage:CD00 0000

​	0x0000-成功

　　0x0004-它没有正确生成或匹配标记不存在

　　0x0005-引用的特定项（通常是实例）无法找到

　　0x0006-请求的数据量不适合响应缓冲区。 发生了部分数据传输

　　0x000A-尝试处理其中一个属性时发生错误

　　0x0013-命令中没有提供足够的命令数据/参数来执行所请求的服务

　　0x001C-与属性计数相比，提供的属性数量不足

　　0x001E-此服务中的服务请求出错

　　0x0020-命令中参数的数据类型与实际参数的数据类型不一致

　　0x0026-IOI字长与处理的IOI数量不匹配



# Omron自带的说明文档

## 正确使用规则（中文简略版）

- USB端口是独占，SYSMAC Gateway USB connection 占有端口，别人就用不了，别人占了，SYSMAC Gateway USB connection 就使用不了。
- FgwGlobalFactory服务不能关，NameSpaceServer服务为了使用内存名字和标签名字也不能关
- SYSMAC Gateway / FinsGateway 在64位操作系统中，作为32位进程运行
- SYSMAC Gateway 运行时需要.NET Framework 3.5 SP1
- (**这一条含义不是特别清楚**)CX-Compolet的公共静态(Visual Basic: shared)成员可以安全地用于多线程操作。实例成员不是线程安全的。由于上述原因和读/写系统规范，同一个实例的多线程操作不是线程安全的，无论该操作是读还是写。执行适当的独占控制或为每个线程创建一个实例。可以安全地使用从不同实例到同一地址的访问，因为内部执行排他性控制。
- 使用SYSMAC Gateway需要以管理员的用户身份登录到计算机

## 引用文档（和NJ/NX/NY控制器数据交换）

1. NJ/NX/ ny系列CPU单元与SYSMAC网关或消息通信(服务器)之间通过数据链进行结构变量的数据交换有以下注意事项。

   - 您需要将结构变量成员的内存配置与SYSMAC Gateway的内存配置保持一致。SYSMAC Gateway的内存配置与cj2系列CPU相同。

   - 有两种方法可以使内存配置与NJ/NX/ ny系列CPU单元保持一致。例如，nj系列CPU单元和SYSMAC网关在结构变量的内存配置方面的差异如下所示。

     - ![image-20240927105848216](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927105848216.png)

     - **修改NJ/NX/ ny系列CPU结构变量的内存配置  offset偏移量**

       - 当NJ/NX/ ny系列CPU需要改变结构变量的内存配置时，可以通过指定成员偏移量来改变结构变量成员的内存配置。您可以更改NJ/NX/ ny系列CPU单元中结构变量成员的内存配置，使其与CPU单元将要通信的SYSMAC Gateway中的内存配置相同。
       - 如果通过设置偏移量的方式改变了某个结构变量的内存配置，则必须在网络中其他NJ/NX/ ny系列CPU单元中修改该结构变量的内存配置。
       - 下面以nj系列CPU Unit中结构变量的内存配置与SYSMAC Gateway中结构变量的内存配置相匹配为例进行说明。
         - ![image-20240927111133062](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927111133062.png)
         - ![image-20240927111213597](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927111213597.png)

     - **修改SYSMAC网关中结构变量的内存配置**

       - 可以在SYSMAC Gateway的结构变量中插入成员，使其与NJ/NX/ ny系列CPU单元中结构变量的内存配置相匹配。

         两个结构变量之间的内存配置和数据类型必须相同。因此，您需要在SYSMAC Gateway和NJ/NX/ ny系列CPU单元中创建相同的成员。

       - 下面的示例显示了如何更改SYSMAC Gateway中结构变量的内存配置，以匹配nj系列CPU单元中结构变量的内存配置。（这里面说的是虚拟变量）

         - ​	![image-20240927112357138](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927112357138.png)

       - 在SYSMAC网关中，采用方法2有以下限制。
       
         <table>
           <capital>使用方法2的一些限制，简略版</capital>
           <tr>
             <th rowspan=2>限制</th>
             <th colspan=2>可选措施，替代手段</th>
           </tr>
            <tr>
             <td>Provided</td>
             <td>Actions(措施)</td>
           </tr>
           <tr>
             <th>SYSMAC网关不支持以下NJ/NX/ny系列控制器提供的数据类型。BYTE, SINT, USINT，时间，日期，时间，日期，日期，联合，枚举</th>
             <td>Provided</td>
             <td>进行链路设置，使NJ/NX/ ny系列控制器和SYSMAC网关之间的数据类型和大小尽可能一致。<br/>
               Example: NJ：BYTE[2]  SYSMAC Gateway: WORD。可以用可以读取的变量替代
             </td>
           </tr>
           <tr>
             <th>NJ/NX/ ny系列控制器不支持以下SYSMAC Gateway中提供的数据类型。
         通道，uint_bcd, udint_bcd, ulint_bcd</th>
             <td>Provided</td>
             <td>
               进行链路设置，使NJ/NX/ ny系列控制器和SYSMAC网关之间的数据类型和大小尽可能一致.<br/>
               Example:<br/>  
               NJ-series Controller: UINT,
               SYSMAC Gateway: UINT_BCD<br/>  
               NJ-series Controller: UDINT,
               SYSMAC Gateway: UDINT_BCD<br/>  
               NJ-series Controller: ULINT,
               SYSMAC Gateway: ULINT_BCD<br/>  
               可以像上面那样设置标签数据链。但是，现值的数据范围将是有限的。
             </td>
           </tr>
            <tr>
             <th>上下字节在STRING数据中交换。如果NJ/NX/ ny系列控制器与SYSMAC网关之间存在字符串数据的tag datalink，则交换上下字节。</th>
             <td>None</td>
             <td>为NJ/NX/NY系列控制器和SYSMAC网关之间的STRING数据设置如下数据链。<br/>NJ系列控制器:abcdefgi到SYSMAC网关:badcfeig交换上字节和下字节。从SYSMAC网关到nj系列控制器的数据链路使用相同的方法。
              </td>
           </tr>
            <tr>
             <th>
               对于不同数据类型的数组之间的标记数据链，预期的数据位置是不同的。对于不同数据类型的阵列使用标签数据链时，如果使链路大小相同，则可以建立标签数据链，但会偏离数据位置。<br/>nj系列控制器中的SINT数组和SYSMAC网关中的INT数组之间的标记数据链nj系列控制器:SINT[1][600];SYSMAC网关:INT[1][300]->标签数据链接是可能的，因为链接大小是相同的(600字节)。但是，由于每个单位的数据量不同，相应的数据位置会不同(NJ/NX/ ny系列控制器:1字节，SYSMAC网关:2字节)。
         </th>
             <td>Provided</td>
             <td>仅使用标记数据链中使用的标记可以处理的最小数据范围作为当前值</td>
           </tr>
            <tr>
             <th>在以下情况下，即使在结构的相同数据类型之间也不可能使用标记数据链。例子:在BOOL结(5个成员)的标签数据链接的情况下,nj系列控制器:10字节(= 2byte*5);SYSMAC网关:2字节(使用5位，但最小数据大小为2字节)。因此，标签数据链无法建立。但是，标签通常在每个节点中求解。
         </th>
             <td>Provided</td>
             <td>有一些方法可以处理这种限制，如下所示。使用标记集。在标签集中设置BOOL*5标签。使用数组。设置BOOL*5数组。不要在结构中的一行中使用相同的数据类型。例如，按以下顺序指定成员;Bool, int, Bool, int。</td>
           </tr>
           <tr>
             <th>在枚举数据的标记数据链中，只能使用每个成员的枚举值中设置的值。因为变量的枚举类型是只读的，所以在SYSMAC Gateway中只能接收数据。</th>
             <td>Provided</td>
             <td>在发送数据时，使用相同的标记数据类型，而不是枚举数据。</td>
           </tr>
           <tr>
             <th>您需要通过调整结构的标记数据链中的对齐来考虑数据大小。在SYSMAC网关的结构中需要包含一个虚拟成员(例如，通过使用一个数组)。例子:nj系列控制器侧的尺寸计算(下例中以“数据类型，数据大小，调整后(字节)”表示)<br/>“USINT[2] 2,2”<br/>“UINT[2] 2,2”<br/>“UINT[2], 2,4”<br/>->在UDINT之前需要统一到4字节对齐。<br/>UDINT 4,4<br/>UDINT 4,4<br/>ULINT 8,8<br/>ULINT 8,8<br/>REAL 4,8 <br/>->在LREAL之前需要统一到8字节对齐。<br/>
         LREAL 8,8<br/>STRING[10]  10,14</br/>STRING数据需要两个终止字符(NULL)。</th>
             <td>Provided</td>
             <td>SYSMAC网关端的结构处理像UINT[2]， REAL[2]和STRING[14]这样的数组的对齐调整</td>
           </tr>
         	<tr>
             <th>NJ/NX/ ny系列控制器的系统变量不支持标签数据链。</th>
             <td>None</td>
             <td>如果您在网络配置器上注册了系统变量，设备监视器的[标签状态]页签上会显示“属性错误”。
         通常，当在CPU单元(或SYSMAC网关)中注册的标记的网络发布属性与network Configurator设置不同时，会发生此错误。</td>
         	</tr>
         	<tr>
             <th>SYSMAC网关只支持BOOL数据的一维数组。</th>
             <td>Provided</td>
             <td>您可以通过像处理多维数组一样处理一维数组来进行链接设置。<br/>例子:<br/>nj系列控制器端:BOOL[100,48]，<br/> SYSMAC网关端:BOOL[4800]<br/>nj系列控制器:BOOL[1,47]到SYSMAC网关:BOOL[47]<br/>nj系列控制器:BOOL[48,1]到SYSMAC网关:BOOL[48]<br/>nj系列控制器:BOOL[2][47]到SYSMAC网关:BOOL[94]</td>
         	</tr>
         </table>
       
       - 标签数据链接设置示例如下所示
       
         1. 单个标签之间的数据链接
       
            ![image-20240927164549962](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927164549962.png)
       
            Tips：
       
            - 红色的数据类型是 NJ/NX/NY系列控制器支持，但SYSMAC Gateway. 不支持
            - 蓝色的数据类型是SYSMAC Gateway支持，但NJ/NX/NY系列控制器不支持
            - 横杠代表不支持
       
         2. BOOL标签集的标签数据链
       
            ![image-20240927165725932](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927165725932.png)
       
         3. BOOL数组之间的标签数据链
       
            ![image-20240927170728811](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927170728811.png)
       
            数组里面4800位，600字节
       
         4. BYTE数组和WORD数据组之间的标签数据链
       
            ![image-20240927170831986](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927170831986.png)
       
            1 WORD = 2 BYTE；
       
         5. BOOL二维数组的标签数据链
       
            ![image-20240927171102554](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927171102554.png)
       
         6. BOOL结构体之间的标签数据链
       
            ![image-20240927171458067](./%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20240927171458067.png)
       
         7. 略



